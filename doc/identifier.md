Design for Identifier Table

When FuncDeclare is called, all the statements following should be translated to assembly language for that function and stored sequentially after the "entrance code". During this translation, compiler has to know what each identifier means, including local variables and value parameters. As a result, both local variables and value parameters have to be stored in the local identifier table, which is basically a new, empty table constructed just for this function. After FuncDeclare returns, no other function will have access to the local variables and value parameters anymore, so it is safe to destruct the local identifier table before FuncDeclare returns. This applies to VoidFuncDeclare as well.

However, the pointer to the identifier table are stored as a member variable in GrammarDecoder. Thus it is noteworthy that in addition to constructing and destructing the local Identifier Table, the pointer also needs to be changed accordingly. A new pointer pointing to the global Identifier Table has to be added and kept consistent for the whole grammar decoding process so that global constants and variables can be decoded and functions can be stored and called.

It is also noteworthy that no function or void function can be stored in a local identifier table since C doesn’t allow function declaration in another function.

When ConstDeclare is called, actually it doesn’t know whether the constants belong to the local Identifier Table or the global one. Since the static constants can only be declared at the beginning of the source program, it is viable to set both global and local pointers to the global Identifier Table. In this way, ConstDeclare only has to log each constant with the local pointer. After encountering the first function declaration, the local pointer will be changed to point to actual local Identifier Table for a particular function or the main function, where using local pointer to log constants in  ConstDeclare also works.

Now about the address part of the Identifier Table. It is viable to just generate unique labels for global identifiers. For global identifiers are stored in .data (or .bss) section. In the following grammar decoding process, an identifier can be accessed with its label bracketed in square brackets. For local identifiers, both constants and variables are stored in stack of the function. Instructions to allocate space (for variables and constants) and store values (for constants) has to be generated when filling in the Identifier Table and the local identifiers are accessed by its offset from %ebp. This makes it necessary to differentiate between global and local Identifier Table.
