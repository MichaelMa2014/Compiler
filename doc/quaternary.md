Design for Quaternaries

Quaternaries are middle production of the compiler. It is composed of one instruction code, two operands and one destination. Each line of code from the source file will be first translated to quaternaries. Quaternaries will then be optimized and translated to x86 assembly code.

When `Grammar Decoder` encounters a become statement, it will call `Expression` to get the value for the assignment. `Expression` will call `Term` and `Term` will call `Factor` (maybe `Factor` will call `Expression`). In each call, the caller expects the callee to return a value, which will then be used as one of its sources. It is thus important to design how this value is passed. Since the complier cannot use directly the value, it has to store the value in either a register or memory. Since we do not know how the registers will be allocated, we will use memory. Each value will be given a 4-byte block on the stack. The address will be saved in the proper local Identifier Table under the name "1", "2" and so on. Since those are not legal names for user-defined identifiers, there will not be any conflicts. This is a pretty inefficient way because it takes up so many space in memory, but this will allow unified process for number constants as factors, identifiers as factors, matrix member as factors and function calls as factors.

The **unified** process are described here. Each quaternary contains an instruction code, two pointers to identifiers acting as operands and one pointer to identifier as destination. This though, only applies to arithmetic operations, whose meaning is to do calculations between two (or one) identifiers (user-defined or compiler-generated) and assign the result to another.

There are, however, other instructions apart from arithmetic ones that do not fit this process. Some quaternaries have to contain, for example, labels. This will be addressed later.

Now we shall address one of the peculiar instructions that do not fit the pattern, one source of which is a number constant. A new class is derived from `Quaternary`, called `Quaternary_immediate`, for dealing with this instruction. When number constants (AKA immediate numbers) are used as factors, an object of this derived class will be created and used to express the meaning of storing an immediate number to an identifier. This quaternary will be translated to a `mov` instruction in assembly code.

Another kind of the peculiar instructions that do not fit the pattern is to assign value to a matrix member. `mov` instruction will be used but this time we have to provide the address of the matrix member. As a result, it is critical to design how addresses are assigned, which is further addressed in `doc/address.md`. No new class is derived. In the base class, the first source is an identifier pointer pointing to the matrix. The second source is an identifier pointer pointing to the index of the member. The dest is the identifier containing the right value waiting to be assigned. 

Allocating stack space is another peculiar instruction. This instruction does not take any source and destination. It simply means `mov %esp, %esp - 4`. However no derived class is needed because we can just set all three pointers in the base class to `NULL`.

All the quaternaries will be stored in a single table, in the order of generating them. The assembly instructions translated from the quaternaries will also be executed in the order of translating them. As a result, it is critical that the compiler calls the generator in right order.

Each quaternary should be capable of carrying a label. The will be kept when translated to x86 assembly language. The labels should be unique to each other, which makes the index in the table a perfect fit for the job. NASM, however, does not allow labels containing only numbers. So the compiler will add `label` before the indices to generate legal labels. When a label is "set", the compiler will simply set a bool value in the quaternary to `true`, and when translated, the quaternary with `true` value will be printed along with its label.

Now we shall design how the grammar decoder and other components can locate and set the label of a particular quaternary. Label is used in `IfStat`, `WhileStat`, `SwitchStat` and `ReturnStat`.
