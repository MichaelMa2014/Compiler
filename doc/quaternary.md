Quaternaries are middle production of the compiler. It is composed of one instruction code, two operands and one destination. Each line of code from the source file will be first translated to quaternaries. Quaternaries will then be optimized and translated to x86 assembly code.

When `Grammar Decoder` encounters a become statement, it will call `Expression` to get the value for the assignment. `Expression` will call `Term` and `Term` will call `Factor` (maybe `Factor` will call `Expression`). In each call, the caller expects the callee to return a value, which will then be used as one of its sources. It is thus important to design how this value is passed. Since the complier cannot use directly the value, it has to store the value in either a register or memory. Since we do not know how the registers will be allocated, we will use memory. Each value will be given a 4-byte block on the stack. The address will be saved in the proper local Identifier Table under the name "1", "2" and so on. Since those are not legal names for user-defined identifiers, there will not be any conflicts. This is a pretty inefficient way because it takes up so many space in memory, but this will allow unified process for number constants as factors, identifiers as factors, matrix member as factors and function calls as factors.

The **unified** process are described here. Each quaternary contains an instruction code, two pointers to identifiers acting as operands and one pointer to identifier as destination. This though, only applies to arithmetic operations, whose meaning is to do calculations between two (or one) identifiers (user-defined or compiler-generated) and assign the result to another.

There are, however, other instructions apart from arithmetic ones that do not fit this process. Some quaternaries have to contain, for example, labels. This will be addressed later.

Now we shall address one of the peculiar instructions that do not fit the pattern, one source of which is a number constant. A new class is derived from `Quaternary`, called `Quaternary_immediate`, for dealing with this instruction. When number constants (AKA immediate numbers) are used as factors, an object of this derived class will be created and used to express the meaning of storing an immediate number to an identifier. This quaternary will be translated to a `mov` instruction in assembly code.

All the quaternaries will be stored in a single table, in the order of generating them. The assembly instructions translated from the quaternaries will also be excuted in the order of translating them. As a result, it is critical that the compiler calls the generator in right order.
