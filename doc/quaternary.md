Quarternaries are middle production of the compiler. It is composed of one instruction code, two oprands and one destination. Each line of code from the source file will be first translated to quaternaries. Quaternaries will then be optimized and translated to x86 assmbly code.

When Grammar Decoder encounters a become statement, it will call Expression to get the value for the assignment. Expression will call Term and Term will call Factor (maybe Factor will call Expression). In each call, the caller expects the callee to return a value, which will then be used as one of its sources. It is thus important to design how this value is passed. Since the complier cannot use directly the value, it has to store the value in either a register or memory. Since we do not know how the registers will be allocated, we will use memory. Each value will be given a 4-byte block on the stack. The address will be saved in the proper local Identifier Table under the name "1", "2" and so on. Since those are not legal names for user-defined identifiers, there will not be any confliction. This is a pretty ineffecient way because it takes up so many space in memory, but this will allow unified process for number constants as factors, identifiers as factors, matrix member as factors and function calls as factors.

The **unified** process are described here. Each quaternary contains an instruction code, two pointers to identifiers acting as oprands and one pointer to identifier as destination. This though, only applies to arithematic operations, whose meaning is to do calculations between two (or one) identifiers (user-defined or compiler-generated) and assign the result to another.

There are, however, other instrutions apart from arithematic ones that do not fit this process. Some quaternaries have to contain, for example, labels. This will be addressed later.
